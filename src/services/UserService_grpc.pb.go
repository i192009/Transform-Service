// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.1
// source: UserService.proto

package services

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// 校验用户访问凭证
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用TokenService.CheckToken
	CheckToken(ctx context.Context, in *CheckTokenRequest, opts ...grpc.CallOption) (*CheckTokenReply, error)
	// 校验用户访问凭证(流接口)
	CheckTokenStream(ctx context.Context, opts ...grpc.CallOption) (UserService_CheckTokenStreamClient, error)
	// 获取用户信息，返回的是叠加应用信息的合成用户信息
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.GetUserInfo
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*CompoundInfoReply, error)
	// 批量获取用户信息，返回的是叠加应用信息的合成用户信息列表
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.BatchGetUserInfo
	GetUserBatch(ctx context.Context, in *GetUserBatchRequest, opts ...grpc.CallOption) (*CompoundInfoBatchReply, error)
	// 分页获取应用用户列表
	GetUserList(ctx context.Context, in *GetUserListRequest, opts ...grpc.CallOption) (*SketchyInfoPageReply, error)
	// 获取头像库头像
	GetAvatars(ctx context.Context, in *C2S_GetAvatars_Req, opts ...grpc.CallOption) (*S2C_GetAvatars_Rpn, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CheckToken(ctx context.Context, in *CheckTokenRequest, opts ...grpc.CallOption) (*CheckTokenReply, error) {
	out := new(CheckTokenReply)
	err := c.cc.Invoke(ctx, "/user.UserService/CheckToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CheckTokenStream(ctx context.Context, opts ...grpc.CallOption) (UserService_CheckTokenStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &UserService_ServiceDesc.Streams[0], "/user.UserService/CheckTokenStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &userServiceCheckTokenStreamClient{stream}
	return x, nil
}

type UserService_CheckTokenStreamClient interface {
	Send(*CheckTokenStreamRequest) error
	Recv() (*CheckTokenStreamReply, error)
	grpc.ClientStream
}

type userServiceCheckTokenStreamClient struct {
	grpc.ClientStream
}

func (x *userServiceCheckTokenStreamClient) Send(m *CheckTokenStreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *userServiceCheckTokenStreamClient) Recv() (*CheckTokenStreamReply, error) {
	m := new(CheckTokenStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*CompoundInfoReply, error) {
	out := new(CompoundInfoReply)
	err := c.cc.Invoke(ctx, "/user.UserService/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserBatch(ctx context.Context, in *GetUserBatchRequest, opts ...grpc.CallOption) (*CompoundInfoBatchReply, error) {
	out := new(CompoundInfoBatchReply)
	err := c.cc.Invoke(ctx, "/user.UserService/GetUserBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserList(ctx context.Context, in *GetUserListRequest, opts ...grpc.CallOption) (*SketchyInfoPageReply, error) {
	out := new(SketchyInfoPageReply)
	err := c.cc.Invoke(ctx, "/user.UserService/GetUserList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetAvatars(ctx context.Context, in *C2S_GetAvatars_Req, opts ...grpc.CallOption) (*S2C_GetAvatars_Rpn, error) {
	out := new(S2C_GetAvatars_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserService/GetAvatars", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	// 校验用户访问凭证
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用TokenService.CheckToken
	CheckToken(context.Context, *CheckTokenRequest) (*CheckTokenReply, error)
	// 校验用户访问凭证(流接口)
	CheckTokenStream(UserService_CheckTokenStreamServer) error
	// 获取用户信息，返回的是叠加应用信息的合成用户信息
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.GetUserInfo
	GetUser(context.Context, *GetUserRequest) (*CompoundInfoReply, error)
	// 批量获取用户信息，返回的是叠加应用信息的合成用户信息列表
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.BatchGetUserInfo
	GetUserBatch(context.Context, *GetUserBatchRequest) (*CompoundInfoBatchReply, error)
	// 分页获取应用用户列表
	GetUserList(context.Context, *GetUserListRequest) (*SketchyInfoPageReply, error)
	// 获取头像库头像
	GetAvatars(context.Context, *C2S_GetAvatars_Req) (*S2C_GetAvatars_Rpn, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) CheckToken(context.Context, *CheckTokenRequest) (*CheckTokenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckToken not implemented")
}
func (UnimplementedUserServiceServer) CheckTokenStream(UserService_CheckTokenStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CheckTokenStream not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*CompoundInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserBatch(context.Context, *GetUserBatchRequest) (*CompoundInfoBatchReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserBatch not implemented")
}
func (UnimplementedUserServiceServer) GetUserList(context.Context, *GetUserListRequest) (*SketchyInfoPageReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserList not implemented")
}
func (UnimplementedUserServiceServer) GetAvatars(context.Context, *C2S_GetAvatars_Req) (*S2C_GetAvatars_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvatars not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserService/CheckToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CheckToken(ctx, req.(*CheckTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CheckTokenStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(UserServiceServer).CheckTokenStream(&userServiceCheckTokenStreamServer{stream})
}

type UserService_CheckTokenStreamServer interface {
	Send(*CheckTokenStreamReply) error
	Recv() (*CheckTokenStreamRequest, error)
	grpc.ServerStream
}

type userServiceCheckTokenStreamServer struct {
	grpc.ServerStream
}

func (x *userServiceCheckTokenStreamServer) Send(m *CheckTokenStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *userServiceCheckTokenStreamServer) Recv() (*CheckTokenStreamRequest, error) {
	m := new(CheckTokenStreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserService/GetUserBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserBatch(ctx, req.(*GetUserBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserService/GetUserList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserList(ctx, req.(*GetUserListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetAvatars_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_GetAvatars_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetAvatars(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserService/GetAvatars",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetAvatars(ctx, req.(*C2S_GetAvatars_Req))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckToken",
			Handler:    _UserService_CheckToken_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "GetUserBatch",
			Handler:    _UserService_GetUserBatch_Handler,
		},
		{
			MethodName: "GetUserList",
			Handler:    _UserService_GetUserList_Handler,
		},
		{
			MethodName: "GetAvatars",
			Handler:    _UserService_GetAvatars_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CheckTokenStream",
			Handler:       _UserService_CheckTokenStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "UserService.proto",
}

// UserBasicServiceClient is the client API for UserBasicService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserBasicServiceClient interface {
	// 首次登录创建用户
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.CreateUser
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserReply, error)
	// 获取用户访问凭证（将更新授权应用、第三方账户传来的用户信息）
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用TokenService.GetAccessToken
	GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...grpc.CallOption) (*GetAccessTokenReply, error)
	// 更新用户基本信息
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.UpdateUserInfo
	UpdateUserBasic(ctx context.Context, in *UpdateUserBasicRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 获取基本信息中的联系信息，仅在账户系统找回密码第一步调用时使用
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.GetUserInfo
	GetUserContact(ctx context.Context, in *GetUserContactRequest, opts ...grpc.CallOption) (*UserContactReply, error)
	// 注销用户访问凭证，在登录账户信息发生变化时使用
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.RevokeAccessToken
	RevokeAccessToken(ctx context.Context, in *C2S_RevokeAccessToken_Req, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userBasicServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserBasicServiceClient(cc grpc.ClientConnInterface) UserBasicServiceClient {
	return &userBasicServiceClient{cc}
}

func (c *userBasicServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserReply, error) {
	out := new(CreateUserReply)
	err := c.cc.Invoke(ctx, "/user.UserBasicService/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) GetAccessToken(ctx context.Context, in *GetAccessTokenRequest, opts ...grpc.CallOption) (*GetAccessTokenReply, error) {
	out := new(GetAccessTokenReply)
	err := c.cc.Invoke(ctx, "/user.UserBasicService/GetAccessToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) UpdateUserBasic(ctx context.Context, in *UpdateUserBasicRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/user.UserBasicService/UpdateUserBasic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) GetUserContact(ctx context.Context, in *GetUserContactRequest, opts ...grpc.CallOption) (*UserContactReply, error) {
	out := new(UserContactReply)
	err := c.cc.Invoke(ctx, "/user.UserBasicService/GetUserContact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userBasicServiceClient) RevokeAccessToken(ctx context.Context, in *C2S_RevokeAccessToken_Req, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/user.UserBasicService/RevokeAccessToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserBasicServiceServer is the server API for UserBasicService service.
// All implementations must embed UnimplementedUserBasicServiceServer
// for forward compatibility
type UserBasicServiceServer interface {
	// 首次登录创建用户
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.CreateUser
	CreateUser(context.Context, *CreateUserRequest) (*CreateUserReply, error)
	// 获取用户访问凭证（将更新授权应用、第三方账户传来的用户信息）
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用TokenService.GetAccessToken
	GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenReply, error)
	// 更新用户基本信息
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.UpdateUserInfo
	UpdateUserBasic(context.Context, *UpdateUserBasicRequest) (*emptypb.Empty, error)
	// 获取基本信息中的联系信息，仅在账户系统找回密码第一步调用时使用
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.GetUserInfo
	GetUserContact(context.Context, *GetUserContactRequest) (*UserContactReply, error)
	// 注销用户访问凭证，在登录账户信息发生变化时使用
	// @Deprecated 本接口已废弃，可以使用，不再更新。新接入请使用UserServiceV2.RevokeAccessToken
	RevokeAccessToken(context.Context, *C2S_RevokeAccessToken_Req) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserBasicServiceServer()
}

// UnimplementedUserBasicServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserBasicServiceServer struct {
}

func (UnimplementedUserBasicServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserBasicServiceServer) GetAccessToken(context.Context, *GetAccessTokenRequest) (*GetAccessTokenReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessToken not implemented")
}
func (UnimplementedUserBasicServiceServer) UpdateUserBasic(context.Context, *UpdateUserBasicRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserBasic not implemented")
}
func (UnimplementedUserBasicServiceServer) GetUserContact(context.Context, *GetUserContactRequest) (*UserContactReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserContact not implemented")
}
func (UnimplementedUserBasicServiceServer) RevokeAccessToken(context.Context, *C2S_RevokeAccessToken_Req) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAccessToken not implemented")
}
func (UnimplementedUserBasicServiceServer) mustEmbedUnimplementedUserBasicServiceServer() {}

// UnsafeUserBasicServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserBasicServiceServer will
// result in compilation errors.
type UnsafeUserBasicServiceServer interface {
	mustEmbedUnimplementedUserBasicServiceServer()
}

func RegisterUserBasicServiceServer(s grpc.ServiceRegistrar, srv UserBasicServiceServer) {
	s.RegisterService(&UserBasicService_ServiceDesc, srv)
}

func _UserBasicService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserBasicService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAccessTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).GetAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserBasicService/GetAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).GetAccessToken(ctx, req.(*GetAccessTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_UpdateUserBasic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserBasicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).UpdateUserBasic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserBasicService/UpdateUserBasic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).UpdateUserBasic(ctx, req.(*UpdateUserBasicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_GetUserContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).GetUserContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserBasicService/GetUserContact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).GetUserContact(ctx, req.(*GetUserContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserBasicService_RevokeAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_RevokeAccessToken_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserBasicServiceServer).RevokeAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserBasicService/RevokeAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserBasicServiceServer).RevokeAccessToken(ctx, req.(*C2S_RevokeAccessToken_Req))
	}
	return interceptor(ctx, in, info, handler)
}

// UserBasicService_ServiceDesc is the grpc.ServiceDesc for UserBasicService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserBasicService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserBasicService",
	HandlerType: (*UserBasicServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserBasicService_CreateUser_Handler,
		},
		{
			MethodName: "GetAccessToken",
			Handler:    _UserBasicService_GetAccessToken_Handler,
		},
		{
			MethodName: "UpdateUserBasic",
			Handler:    _UserBasicService_UpdateUserBasic_Handler,
		},
		{
			MethodName: "GetUserContact",
			Handler:    _UserBasicService_GetUserContact_Handler,
		},
		{
			MethodName: "RevokeAccessToken",
			Handler:    _UserBasicService_RevokeAccessToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "UserService.proto",
}

// UserServiceV2Client is the client API for UserServiceV2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceV2Client interface {
	// 创建第三方用户
	CreateUser(ctx context.Context, in *C2S_UserCreateV2_Req, opts ...grpc.CallOption) (*S2C_UserCreateV2_Rpn, error)
	// 创建子虔用户
	CreateJumeauxUser(ctx context.Context, in *C2S_JumeauxUserCreateV2_Req, opts ...grpc.CallOption) (*S2C_JumeauxUserCreateV2_Rpn, error)
	// 获取用户信息
	GetUserInfo(ctx context.Context, in *C2S_UserInfoGetV2_Req, opts ...grpc.CallOption) (*S2C_UserInfoGetV2_Rpn, error)
	// 批量获取用户信息
	BatchGetUserInfo(ctx context.Context, in *C2S_BatchUserInfoGetV2_Req, opts ...grpc.CallOption) (*S2C_BatchUserInfoGetV2_Rpn, error)
	// 更新用户信息，仅允许更新非敏用户信息
	UpdateUserInfo(ctx context.Context, in *C2S_UserInfoUpdateV2_Req, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 创建用户身份
	// 如果已有对应身份，将返回现有身份的UserId、UnionId、OpenId
	CreateIdentity(ctx context.Context, in *C2S_IdentityCreate_Req, opts ...grpc.CallOption) (*S2C_IdentityCreate_Rpn, error)
	// 获取用户身份
	// 可设置身份不存在时是否自动创建
	BatchGetIdentities(ctx context.Context, in *C2S_IdentitiesBatchGet_Req, opts ...grpc.CallOption) (*S2C_IdentitiesBatchGet_Rpn, error)
	// 根据账户获取用户身份
	GetIdentityByAccount(ctx context.Context, in *C2S_IdentityGetByAccount_Req, opts ...grpc.CallOption) (*S2C_IdentityGetByAccount_Rpn, error)
	// 查询用户列表
	QueryUser(ctx context.Context, in *C2S_UserQueryReqT, opts ...grpc.CallOption) (*S2C_UserQueryRpnT, error)
}

type userServiceV2Client struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceV2Client(cc grpc.ClientConnInterface) UserServiceV2Client {
	return &userServiceV2Client{cc}
}

func (c *userServiceV2Client) CreateUser(ctx context.Context, in *C2S_UserCreateV2_Req, opts ...grpc.CallOption) (*S2C_UserCreateV2_Rpn, error) {
	out := new(S2C_UserCreateV2_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/CreateUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) CreateJumeauxUser(ctx context.Context, in *C2S_JumeauxUserCreateV2_Req, opts ...grpc.CallOption) (*S2C_JumeauxUserCreateV2_Rpn, error) {
	out := new(S2C_JumeauxUserCreateV2_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/CreateJumeauxUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) GetUserInfo(ctx context.Context, in *C2S_UserInfoGetV2_Req, opts ...grpc.CallOption) (*S2C_UserInfoGetV2_Rpn, error) {
	out := new(S2C_UserInfoGetV2_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/GetUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) BatchGetUserInfo(ctx context.Context, in *C2S_BatchUserInfoGetV2_Req, opts ...grpc.CallOption) (*S2C_BatchUserInfoGetV2_Rpn, error) {
	out := new(S2C_BatchUserInfoGetV2_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/BatchGetUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) UpdateUserInfo(ctx context.Context, in *C2S_UserInfoUpdateV2_Req, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/UpdateUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) CreateIdentity(ctx context.Context, in *C2S_IdentityCreate_Req, opts ...grpc.CallOption) (*S2C_IdentityCreate_Rpn, error) {
	out := new(S2C_IdentityCreate_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/CreateIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) BatchGetIdentities(ctx context.Context, in *C2S_IdentitiesBatchGet_Req, opts ...grpc.CallOption) (*S2C_IdentitiesBatchGet_Rpn, error) {
	out := new(S2C_IdentitiesBatchGet_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/BatchGetIdentities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) GetIdentityByAccount(ctx context.Context, in *C2S_IdentityGetByAccount_Req, opts ...grpc.CallOption) (*S2C_IdentityGetByAccount_Rpn, error) {
	out := new(S2C_IdentityGetByAccount_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/GetIdentityByAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceV2Client) QueryUser(ctx context.Context, in *C2S_UserQueryReqT, opts ...grpc.CallOption) (*S2C_UserQueryRpnT, error) {
	out := new(S2C_UserQueryRpnT)
	err := c.cc.Invoke(ctx, "/user.UserServiceV2/QueryUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceV2Server is the server API for UserServiceV2 service.
// All implementations must embed UnimplementedUserServiceV2Server
// for forward compatibility
type UserServiceV2Server interface {
	// 创建第三方用户
	CreateUser(context.Context, *C2S_UserCreateV2_Req) (*S2C_UserCreateV2_Rpn, error)
	// 创建子虔用户
	CreateJumeauxUser(context.Context, *C2S_JumeauxUserCreateV2_Req) (*S2C_JumeauxUserCreateV2_Rpn, error)
	// 获取用户信息
	GetUserInfo(context.Context, *C2S_UserInfoGetV2_Req) (*S2C_UserInfoGetV2_Rpn, error)
	// 批量获取用户信息
	BatchGetUserInfo(context.Context, *C2S_BatchUserInfoGetV2_Req) (*S2C_BatchUserInfoGetV2_Rpn, error)
	// 更新用户信息，仅允许更新非敏用户信息
	UpdateUserInfo(context.Context, *C2S_UserInfoUpdateV2_Req) (*emptypb.Empty, error)
	// 创建用户身份
	// 如果已有对应身份，将返回现有身份的UserId、UnionId、OpenId
	CreateIdentity(context.Context, *C2S_IdentityCreate_Req) (*S2C_IdentityCreate_Rpn, error)
	// 获取用户身份
	// 可设置身份不存在时是否自动创建
	BatchGetIdentities(context.Context, *C2S_IdentitiesBatchGet_Req) (*S2C_IdentitiesBatchGet_Rpn, error)
	// 根据账户获取用户身份
	GetIdentityByAccount(context.Context, *C2S_IdentityGetByAccount_Req) (*S2C_IdentityGetByAccount_Rpn, error)
	// 查询用户列表
	QueryUser(context.Context, *C2S_UserQueryReqT) (*S2C_UserQueryRpnT, error)
	mustEmbedUnimplementedUserServiceV2Server()
}

// UnimplementedUserServiceV2Server must be embedded to have forward compatible implementations.
type UnimplementedUserServiceV2Server struct {
}

func (UnimplementedUserServiceV2Server) CreateUser(context.Context, *C2S_UserCreateV2_Req) (*S2C_UserCreateV2_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceV2Server) CreateJumeauxUser(context.Context, *C2S_JumeauxUserCreateV2_Req) (*S2C_JumeauxUserCreateV2_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateJumeauxUser not implemented")
}
func (UnimplementedUserServiceV2Server) GetUserInfo(context.Context, *C2S_UserInfoGetV2_Req) (*S2C_UserInfoGetV2_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserServiceV2Server) BatchGetUserInfo(context.Context, *C2S_BatchUserInfoGetV2_Req) (*S2C_BatchUserInfoGetV2_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetUserInfo not implemented")
}
func (UnimplementedUserServiceV2Server) UpdateUserInfo(context.Context, *C2S_UserInfoUpdateV2_Req) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserServiceV2Server) CreateIdentity(context.Context, *C2S_IdentityCreate_Req) (*S2C_IdentityCreate_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIdentity not implemented")
}
func (UnimplementedUserServiceV2Server) BatchGetIdentities(context.Context, *C2S_IdentitiesBatchGet_Req) (*S2C_IdentitiesBatchGet_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetIdentities not implemented")
}
func (UnimplementedUserServiceV2Server) GetIdentityByAccount(context.Context, *C2S_IdentityGetByAccount_Req) (*S2C_IdentityGetByAccount_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIdentityByAccount not implemented")
}
func (UnimplementedUserServiceV2Server) QueryUser(context.Context, *C2S_UserQueryReqT) (*S2C_UserQueryRpnT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUser not implemented")
}
func (UnimplementedUserServiceV2Server) mustEmbedUnimplementedUserServiceV2Server() {}

// UnsafeUserServiceV2Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceV2Server will
// result in compilation errors.
type UnsafeUserServiceV2Server interface {
	mustEmbedUnimplementedUserServiceV2Server()
}

func RegisterUserServiceV2Server(s grpc.ServiceRegistrar, srv UserServiceV2Server) {
	s.RegisterService(&UserServiceV2_ServiceDesc, srv)
}

func _UserServiceV2_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_UserCreateV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).CreateUser(ctx, req.(*C2S_UserCreateV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_CreateJumeauxUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_JumeauxUserCreateV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).CreateJumeauxUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/CreateJumeauxUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).CreateJumeauxUser(ctx, req.(*C2S_JumeauxUserCreateV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_UserInfoGetV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/GetUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).GetUserInfo(ctx, req.(*C2S_UserInfoGetV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_BatchGetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_BatchUserInfoGetV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).BatchGetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/BatchGetUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).BatchGetUserInfo(ctx, req.(*C2S_BatchUserInfoGetV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_UserInfoUpdateV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/UpdateUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).UpdateUserInfo(ctx, req.(*C2S_UserInfoUpdateV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_CreateIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_IdentityCreate_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).CreateIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/CreateIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).CreateIdentity(ctx, req.(*C2S_IdentityCreate_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_BatchGetIdentities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_IdentitiesBatchGet_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).BatchGetIdentities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/BatchGetIdentities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).BatchGetIdentities(ctx, req.(*C2S_IdentitiesBatchGet_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_GetIdentityByAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_IdentityGetByAccount_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).GetIdentityByAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/GetIdentityByAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).GetIdentityByAccount(ctx, req.(*C2S_IdentityGetByAccount_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserServiceV2_QueryUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_UserQueryReqT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceV2Server).QueryUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserServiceV2/QueryUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceV2Server).QueryUser(ctx, req.(*C2S_UserQueryReqT))
	}
	return interceptor(ctx, in, info, handler)
}

// UserServiceV2_ServiceDesc is the grpc.ServiceDesc for UserServiceV2 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserServiceV2_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserServiceV2",
	HandlerType: (*UserServiceV2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserServiceV2_CreateUser_Handler,
		},
		{
			MethodName: "CreateJumeauxUser",
			Handler:    _UserServiceV2_CreateJumeauxUser_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserServiceV2_GetUserInfo_Handler,
		},
		{
			MethodName: "BatchGetUserInfo",
			Handler:    _UserServiceV2_BatchGetUserInfo_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _UserServiceV2_UpdateUserInfo_Handler,
		},
		{
			MethodName: "CreateIdentity",
			Handler:    _UserServiceV2_CreateIdentity_Handler,
		},
		{
			MethodName: "BatchGetIdentities",
			Handler:    _UserServiceV2_BatchGetIdentities_Handler,
		},
		{
			MethodName: "GetIdentityByAccount",
			Handler:    _UserServiceV2_GetIdentityByAccount_Handler,
		},
		{
			MethodName: "QueryUser",
			Handler:    _UserServiceV2_QueryUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "UserService.proto",
}

// TokenServiceClient is the client API for TokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TokenServiceClient interface {
	// 获取用户访问凭证（将更新授权应用、第三方账户传来的用户信息）
	GetAccessToken(ctx context.Context, in *C2S_AccessTokenGetV2_Req, opts ...grpc.CallOption) (*S2C_AccessTokenGetV2_Rpn, error)
	// 注销用户访问凭证，在登录账户信息发生变化时使用
	RevokeAccessToken(ctx context.Context, in *C2S_RevokeAccessTokenV2_Req, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 注销用户全部访问凭证，在登录账户信息发生变化时使用
	RevokeAllAccessToken(ctx context.Context, in *C2S_RevokeAllAccessTokenV2_Req, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 校验用户访问凭证
	CheckToken(ctx context.Context, in *C2S_CheckTokenV2_Req, opts ...grpc.CallOption) (*S2C_CheckTokenV2_Rpn, error)
}

type tokenServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTokenServiceClient(cc grpc.ClientConnInterface) TokenServiceClient {
	return &tokenServiceClient{cc}
}

func (c *tokenServiceClient) GetAccessToken(ctx context.Context, in *C2S_AccessTokenGetV2_Req, opts ...grpc.CallOption) (*S2C_AccessTokenGetV2_Rpn, error) {
	out := new(S2C_AccessTokenGetV2_Rpn)
	err := c.cc.Invoke(ctx, "/user.TokenService/GetAccessToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) RevokeAccessToken(ctx context.Context, in *C2S_RevokeAccessTokenV2_Req, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/user.TokenService/RevokeAccessToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) RevokeAllAccessToken(ctx context.Context, in *C2S_RevokeAllAccessTokenV2_Req, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/user.TokenService/RevokeAllAccessToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) CheckToken(ctx context.Context, in *C2S_CheckTokenV2_Req, opts ...grpc.CallOption) (*S2C_CheckTokenV2_Rpn, error) {
	out := new(S2C_CheckTokenV2_Rpn)
	err := c.cc.Invoke(ctx, "/user.TokenService/CheckToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TokenServiceServer is the server API for TokenService service.
// All implementations must embed UnimplementedTokenServiceServer
// for forward compatibility
type TokenServiceServer interface {
	// 获取用户访问凭证（将更新授权应用、第三方账户传来的用户信息）
	GetAccessToken(context.Context, *C2S_AccessTokenGetV2_Req) (*S2C_AccessTokenGetV2_Rpn, error)
	// 注销用户访问凭证，在登录账户信息发生变化时使用
	RevokeAccessToken(context.Context, *C2S_RevokeAccessTokenV2_Req) (*emptypb.Empty, error)
	// 注销用户全部访问凭证，在登录账户信息发生变化时使用
	RevokeAllAccessToken(context.Context, *C2S_RevokeAllAccessTokenV2_Req) (*emptypb.Empty, error)
	// 校验用户访问凭证
	CheckToken(context.Context, *C2S_CheckTokenV2_Req) (*S2C_CheckTokenV2_Rpn, error)
	mustEmbedUnimplementedTokenServiceServer()
}

// UnimplementedTokenServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTokenServiceServer struct {
}

func (UnimplementedTokenServiceServer) GetAccessToken(context.Context, *C2S_AccessTokenGetV2_Req) (*S2C_AccessTokenGetV2_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccessToken not implemented")
}
func (UnimplementedTokenServiceServer) RevokeAccessToken(context.Context, *C2S_RevokeAccessTokenV2_Req) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAccessToken not implemented")
}
func (UnimplementedTokenServiceServer) RevokeAllAccessToken(context.Context, *C2S_RevokeAllAccessTokenV2_Req) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeAllAccessToken not implemented")
}
func (UnimplementedTokenServiceServer) CheckToken(context.Context, *C2S_CheckTokenV2_Req) (*S2C_CheckTokenV2_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckToken not implemented")
}
func (UnimplementedTokenServiceServer) mustEmbedUnimplementedTokenServiceServer() {}

// UnsafeTokenServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TokenServiceServer will
// result in compilation errors.
type UnsafeTokenServiceServer interface {
	mustEmbedUnimplementedTokenServiceServer()
}

func RegisterTokenServiceServer(s grpc.ServiceRegistrar, srv TokenServiceServer) {
	s.RegisterService(&TokenService_ServiceDesc, srv)
}

func _TokenService_GetAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_AccessTokenGetV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).GetAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.TokenService/GetAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).GetAccessToken(ctx, req.(*C2S_AccessTokenGetV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_RevokeAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_RevokeAccessTokenV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).RevokeAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.TokenService/RevokeAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).RevokeAccessToken(ctx, req.(*C2S_RevokeAccessTokenV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_RevokeAllAccessToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_RevokeAllAccessTokenV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).RevokeAllAccessToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.TokenService/RevokeAllAccessToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).RevokeAllAccessToken(ctx, req.(*C2S_RevokeAllAccessTokenV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_CheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_CheckTokenV2_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).CheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.TokenService/CheckToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).CheckToken(ctx, req.(*C2S_CheckTokenV2_Req))
	}
	return interceptor(ctx, in, info, handler)
}

// TokenService_ServiceDesc is the grpc.ServiceDesc for TokenService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TokenService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.TokenService",
	HandlerType: (*TokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAccessToken",
			Handler:    _TokenService_GetAccessToken_Handler,
		},
		{
			MethodName: "RevokeAccessToken",
			Handler:    _TokenService_RevokeAccessToken_Handler,
		},
		{
			MethodName: "RevokeAllAccessToken",
			Handler:    _TokenService_RevokeAllAccessToken_Handler,
		},
		{
			MethodName: "CheckToken",
			Handler:    _TokenService_CheckToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "UserService.proto",
}

// UserAdminServiceClient is the client API for UserAdminService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserAdminServiceClient interface {
	// 获取用户后台详情
	GetUserDetail(ctx context.Context, in *C2S_UserAdminDetailGet_Req, opts ...grpc.CallOption) (*S2C_UserAdminDetailGet_Rpn, error)
	// 更新租户层用户信息
	UpdateTenantUserInfo(ctx context.Context, in *C2S_UserAdminUpdate_Req, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAdminServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAdminServiceClient(cc grpc.ClientConnInterface) UserAdminServiceClient {
	return &userAdminServiceClient{cc}
}

func (c *userAdminServiceClient) GetUserDetail(ctx context.Context, in *C2S_UserAdminDetailGet_Req, opts ...grpc.CallOption) (*S2C_UserAdminDetailGet_Rpn, error) {
	out := new(S2C_UserAdminDetailGet_Rpn)
	err := c.cc.Invoke(ctx, "/user.UserAdminService/GetUserDetail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userAdminServiceClient) UpdateTenantUserInfo(ctx context.Context, in *C2S_UserAdminUpdate_Req, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/user.UserAdminService/UpdateTenantUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAdminServiceServer is the server API for UserAdminService service.
// All implementations must embed UnimplementedUserAdminServiceServer
// for forward compatibility
type UserAdminServiceServer interface {
	// 获取用户后台详情
	GetUserDetail(context.Context, *C2S_UserAdminDetailGet_Req) (*S2C_UserAdminDetailGet_Rpn, error)
	// 更新租户层用户信息
	UpdateTenantUserInfo(context.Context, *C2S_UserAdminUpdate_Req) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserAdminServiceServer()
}

// UnimplementedUserAdminServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserAdminServiceServer struct {
}

func (UnimplementedUserAdminServiceServer) GetUserDetail(context.Context, *C2S_UserAdminDetailGet_Req) (*S2C_UserAdminDetailGet_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserDetail not implemented")
}
func (UnimplementedUserAdminServiceServer) UpdateTenantUserInfo(context.Context, *C2S_UserAdminUpdate_Req) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTenantUserInfo not implemented")
}
func (UnimplementedUserAdminServiceServer) mustEmbedUnimplementedUserAdminServiceServer() {}

// UnsafeUserAdminServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAdminServiceServer will
// result in compilation errors.
type UnsafeUserAdminServiceServer interface {
	mustEmbedUnimplementedUserAdminServiceServer()
}

func RegisterUserAdminServiceServer(s grpc.ServiceRegistrar, srv UserAdminServiceServer) {
	s.RegisterService(&UserAdminService_ServiceDesc, srv)
}

func _UserAdminService_GetUserDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_UserAdminDetailGet_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAdminServiceServer).GetUserDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserAdminService/GetUserDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAdminServiceServer).GetUserDetail(ctx, req.(*C2S_UserAdminDetailGet_Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserAdminService_UpdateTenantUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_UserAdminUpdate_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAdminServiceServer).UpdateTenantUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.UserAdminService/UpdateTenantUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAdminServiceServer).UpdateTenantUserInfo(ctx, req.(*C2S_UserAdminUpdate_Req))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAdminService_ServiceDesc is the grpc.ServiceDesc for UserAdminService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAdminService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserAdminService",
	HandlerType: (*UserAdminServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserDetail",
			Handler:    _UserAdminService_GetUserDetail_Handler,
		},
		{
			MethodName: "UpdateTenantUserInfo",
			Handler:    _UserAdminService_UpdateTenantUserInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "UserService.proto",
}

// CompatibilityServiceClient is the client API for CompatibilityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CompatibilityServiceClient interface {
	// 根据用户旧openId获取新openId, 如果不存在,会自动生成
	GetNewOpenId(ctx context.Context, in *C2S_NewOpenIdGet_Req, opts ...grpc.CallOption) (*S2C_NewOpenIdGet_Rpn, error)
}

type compatibilityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCompatibilityServiceClient(cc grpc.ClientConnInterface) CompatibilityServiceClient {
	return &compatibilityServiceClient{cc}
}

func (c *compatibilityServiceClient) GetNewOpenId(ctx context.Context, in *C2S_NewOpenIdGet_Req, opts ...grpc.CallOption) (*S2C_NewOpenIdGet_Rpn, error) {
	out := new(S2C_NewOpenIdGet_Rpn)
	err := c.cc.Invoke(ctx, "/user.CompatibilityService/GetNewOpenId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CompatibilityServiceServer is the server API for CompatibilityService service.
// All implementations must embed UnimplementedCompatibilityServiceServer
// for forward compatibility
type CompatibilityServiceServer interface {
	// 根据用户旧openId获取新openId, 如果不存在,会自动生成
	GetNewOpenId(context.Context, *C2S_NewOpenIdGet_Req) (*S2C_NewOpenIdGet_Rpn, error)
	mustEmbedUnimplementedCompatibilityServiceServer()
}

// UnimplementedCompatibilityServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCompatibilityServiceServer struct {
}

func (UnimplementedCompatibilityServiceServer) GetNewOpenId(context.Context, *C2S_NewOpenIdGet_Req) (*S2C_NewOpenIdGet_Rpn, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNewOpenId not implemented")
}
func (UnimplementedCompatibilityServiceServer) mustEmbedUnimplementedCompatibilityServiceServer() {}

// UnsafeCompatibilityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CompatibilityServiceServer will
// result in compilation errors.
type UnsafeCompatibilityServiceServer interface {
	mustEmbedUnimplementedCompatibilityServiceServer()
}

func RegisterCompatibilityServiceServer(s grpc.ServiceRegistrar, srv CompatibilityServiceServer) {
	s.RegisterService(&CompatibilityService_ServiceDesc, srv)
}

func _CompatibilityService_GetNewOpenId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(C2S_NewOpenIdGet_Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CompatibilityServiceServer).GetNewOpenId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/user.CompatibilityService/GetNewOpenId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CompatibilityServiceServer).GetNewOpenId(ctx, req.(*C2S_NewOpenIdGet_Req))
	}
	return interceptor(ctx, in, info, handler)
}

// CompatibilityService_ServiceDesc is the grpc.ServiceDesc for CompatibilityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CompatibilityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.CompatibilityService",
	HandlerType: (*CompatibilityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNewOpenId",
			Handler:    _CompatibilityService_GetNewOpenId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "UserService.proto",
}
